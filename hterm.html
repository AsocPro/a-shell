<!DOCTYPE html>
<html>
	<head>
		<title>a-Shell, terminal</title>
		<meta charset='utf-8'/>
		<meta name="viewport" content="viewport-fit=cover, width=device-width,  height=device-height, initial-scale=1, user-scalable=no">
		<!-- 
	  <script src='../dist/js/hterm_deps.js'></script>
	  <script src='../dist/js/hterm_resources.js'></script>
	  --> 
	  <!-- Dist version.-->
	  <script src='hterm_all.js'></script>
	  <style>
         html {
         	height: 100%;
         }
         body {
         	position: absolute;
         	height: 100%;
         	width: 100%;
         	overflow: hidden;
         	margin: 0px;
         	padding: 0px;
         }
         #terminal {
         	display: block;
         	position: relative;
         	height: 100%;
         	width: 100%;
         	margin: 0px;
         	padding: 0px;
         }
	   </style>
	</head>

	<body>
		<div id='terminal' contenteditable='true' spellcheck='false' autocomplete='off' autocorrect='off' autocapitaliz='none'></div>
		<script>
			function initContent(io) {
				const ver = lib.resource.getData('libdot/changelog/version');
				const date = lib.resource.getData('libdot/changelog/date');
				const pkg = `libdot ${ver} (${date})`;
			};

            function luminance(color) {
				var colorArray = lib.colors.crackRGB(color);
				return colorArray[0] * 0.2126 + colorArray[1] * 0.7152 + colorArray[2] *  0.0722;
			}

            var lastDirectory = '';
            var fileList = [];
            var currentCommandCursorPosition;
            var autocompleteList = []; 
            var autocompleteOn = false;
            var autocompleteIndex = 0;

            function disableAutocompleteMenu() {
				printString('');
				autocompleteOn = false;
				autocompleteList = [];
				autocompleteIndex = 0;
				fileList = '';
				lastDirectory = '';
			}
            
            function isLetter(c) {
            	// TODO: extension for CJK characters (hard)
				return (c.toLowerCase() != c.toUpperCase());
			}

            function printPrompt() {
				// prints the prompt and initializes all variables related to prompt position
				window.term_.io.print(window.prompt); 
			}

            function updatePromptPosition() {
				window.promptEnd = window.term_.screen_.cursorPosition.column;
				// required because some commands can take several lines, especially on a phone.
				window.promptLine = window.term_.screen_.cursorPosition.row;
				window.promptScroll = window.term_.scrollPort_.getTopRowIndex();
				currentCommandCursorPosition = 0; 
			}

            // prints a string and move the rest of the command around, even if it is over multiple lines
            // we use lib.wc.strWidth instead of length because of multiple-width characters (CJK, mostly).
            // TODO: get correct character width for emojis.
            function printString(string) {
				var l = lib.wc.strWidth(string);
				var currentCommand = window.term_.io.currentCommand;
				// clear the rest of the line, then reprint. 
				window.term_.io.print('\x1b[0J'); // delete display after cursor
				window.term_.io.print(string); 
				
				// print remainder of command line
				window.term_.io.print(currentCommand.slice(currentCommandCursorPosition, currentCommand.length))
				// move cursor back to where it was (don't use term.screen_.cursorPosition):
				var endOfCommand = currentCommand.slice(currentCommandCursorPosition, currentCommand.length);
				var endOfCommandWidth = lib.wc.strWidth(endOfCommand);
				for (var i = 0; i < endOfCommandWidth; i++) {
					window.term_.io.print('\b'); 
				}
			}

            // prints a string for autocomplete and move the rest of the command around, even if it is over multiple lines.
            // keep the command as it is until autocomplete has been accepted.
            function printAutocompleteString(string) {
				var currentCommand = window.term_.io.currentCommand;
				// clear entire buffer, then reprint
				window.term_.io.print('\x1b[0J'); // delete display after cursor
				if (luminance(window.term_.getBackgroundColor()) < luminance(window.term_.getForegroundColor())) {
					// We are in dark mode. Use yellow font for higher contrast
					window.term_.io.print('\x1b[33m'); // yellow

				} else {
					window.term_.io.print('\x1b[32m'); // green
				}
				window.term_.io.print(string); 
				window.term_.io.print('\x1b[39m'); // back to normal foreground color
				// print remainder of command line
				window.term_.io.print(currentCommand.slice(currentCommandCursorPosition, currentCommand.length))
				// move cursor back to where it was (don't use term.screen_.cursorPosition):
				// don't use length because of multiple-byte chars.
				var endOfCommand = currentCommand.slice(currentCommandCursorPosition, currentCommand.length);
				var wcwidth = lib.wc.strWidth(endOfCommand) + lib.wc.strWidth(string);
				for (var i = 0; i < wcwidth; i++) {
					window.term_.io.print('\b'); 
				}
			}

            function pickCurrentValue() {
				var currentCommand = window.term_.io.currentCommand;
				var cursorPosition = window.term_.screen_.cursorPosition.column - window.promptEnd;
				selected = autocompleteList[autocompleteIndex]; 
				printString(selected);
				window.term_.io.currentCommand = currentCommand.slice(0, currentCommandCursorPosition) + selected + 
					currentCommand.slice(currentCommandCursorPosition, currentCommand.length);
				// is not enough to push the rest of the command if it's longer than a line
				currentCommandCursorPosition += selected.length;
				disableAutocompleteMenu();
			}
            
            // called once the list of files has been updated, asynchronously. 
            function updateFileMenu() {
				var cursorPosition = window.term_.screen_.cursorPosition.column - window.promptEnd;
				updateAutocompleteMenu(window.term_.io, cursorPosition);
			}

            function updateAutocompleteMenu(io, cursorPosition) {
				var lastFound = '';
				// string to use for research: from beginning of line to cursor position
				var rootForMatch = io.currentCommand.slice(0, currentCommandCursorPosition);
				var predicate = rootForMatch;
				var n = predicate.lastIndexOf("|");
				if (n < predicate.length) {
					var predicate = predicate.substr(n + 1);
				}
				n = predicate.lastIndexOf(" ");
				while ((n > 0) && (predicate[n-1] == "\\")) { 
					// escaped space
					n = predicate.lastIndexOf(" ", n - 1);
				}
				if (n < predicate.length) {
					var predicate = predicate.substr(n + 1);
				}
				n = predicate.lastIndexOf(">");
				if (n < predicate.length) {
					var predicate = predicate.substr(n + 1);
				}
				if (predicate[0] == '-') return; // arguments to function, no autocomplete
				// we have the string to use for matching (predicate). Is it a file or a command?
				var beforePredicate = rootForMatch.substr(0, rootForMatch.lastIndexOf(predicate));
				// remove all trailing spaces:
				while ((beforePredicate.length > 0) && (beforePredicate.slice(-1) == " ")) {
					beforePredicate = beforePredicate.slice(0, beforePredicate.length - 1)
				}
				autocompleteIndex = 0; 
				autocompleteList = [];
				var matchToCommands = false;
				if (beforePredicate.length == 0) {
					matchToCommands = true; // beginning of line, must be a command
				} else if (beforePredicate.slice(-1) == "|") {
					matchToCommands = true; // right after a pipe, must be a command
				}
				// otherwise, it's probably a file
				var numFound = 0; 
				var file = '';
				if (matchToCommands) { 
					for (var i = 0, len = commandList.length; i < len; i++) {
						if (commandList[i].startsWith(predicate)) {
							var value = commandList[i].replace(predicate, "") + ' '; // add a space at the end if it's a command; 
							autocompleteList[numFound] = value;
							lastFound = value; 
							numFound += 1;
						}
					}
				} else {
					if ((predicate[0] == "/") && (predicate.lastIndexOf("/") == 0)) {
						// special case for root
						directory = "/";
						file = predicate.substr(1);
					} else {
						var lastSlash = predicate.lastIndexOf("/");
						if ((predicate.length > 0) && (lastSlash > 0) && (lastSlash < predicate.length)) {
							var directory = predicate.substr(0, lastSlash); // include "/" in directory
							file = predicate.substr(lastSlash + 1); // don't include "/" in file name
						} else {
							var directory = ".";
							file = predicate;
						}
					}
					// Need to get list of files from directory. 
					if (directory == lastDirectory) {
						for (var i = 0, len = fileList.length; i < len; i++) {
							if (fileList[i].startsWith(file)) {
								var value = fileList[i].replace(file, "")
								autocompleteList[numFound] = value; 
								lastFound = value; 
								numFound += 1;
							}
						}
					} else {
						// asynchronous communication. Will have to execute the rest of the command too.
						window.webkit.messageHandlers.aShell.postMessage('listDirectory:' + directory);
					}
				}

				// substring of io.currentCommand, ending at currentCommandCursorPosition, going back until first space or "/"
				// list to use for autocomplete = commandList if at beginning of line (modulo spaces) or after | (module spaces)
				// list of files inside directory otherwise. e.g. "../Library/Preferences/" (going back until next space)
				// TODO: no autocomplete on file for commands that don't operate on files (difficult)
				if (numFound > 1) {
					// If list is not empty:
					autocompleteOn = true;
					while ((autocompleteList[autocompleteIndex][0] == ".") && (autocompleteIndex < autocompleteList.length - 1)) {
						autocompleteIndex += 1;
					} 
					if (autocompleteIndex == autocompleteList.length - 1) {
						// directory with only ".*" files
						autocompleteIndex = 0;
					}
					printAutocompleteString(autocompleteList[autocompleteIndex]);
				} else {
					if (numFound == 1) {
						printString(lastFound);
						io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition) + lastFound + 
							io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length);
						currentCommandCursorPosition += lastFound.length;
					}
					disableAutocompleteMenu(); 
				}
			}

            function setupHterm() {
				const term = new hterm.Terminal();
				// Default monospaced fonts installed: Menlo and Courier. 
				term.prefs_.set('cursor-shape', 'BLOCK'); 
				term.prefs_.set('font-family', 'Menlo');
				term.prefs_.set('font-size', 15);
				term.prefs_.set('cursor-blink', true); 
				term.prefs_.set('enable-clipboard-notice', false); 
				term.prefs_.set('use-default-window-copy', true); 
				term.prefs_.set('clear-selection-after-copy', true); 
				term.prefs_.set('copy-on-select', false);
				term.prefs_.set('audible-bell-sound', '');
				term.prefs_.set('receive-encoding', 'utf-8'); 
				term.prefs_.set('meta-sends-escape', 'false'); 
				
				term.setReverseWraparound(true);
				term.setWraparound(true);
				//
				term.onCut = function(e) { 
					var text = this.getSelectionText();
					// The text has already been copied into the clipboard. 
					// We also need to remove it from the command line -- if it is in.
					var startRow = this.scrollPort_.selection.startRow.rowIndex;
					if (startRow >= window.promptScroll + window.promptLine ) {
						// startOffset = position of selection from start of startRow (not necessarily start of command)
						var startOffset = this.scrollPort_.selection.startOffset;
						// endOffset = position of selection from start of endRow (not used)
						var endOffset = this.scrollPort_.selection.endOffset;
						var startPosition = ((startRow - window.promptScroll - window.promptLine) * this.screenSize.width) + startOffset;
						var xcursor = startOffset;
						var cutText = this.io.currentCommand.slice(startPosition, startPosition + text.length); 
						if (cutText == text) {
							this.io.currentCommand =  this.io.currentCommand.slice(0, startPosition) + this.io.currentCommand.slice(startPosition + text.length, this.io.currentCommand.length); 
							xcursor += window.promptEnd;
						} else {
							// startOffset can sometimes be off by promptLength. 
							startPosition -= window.promptEnd; 
							var cutText = this.io.currentCommand.slice(startPosition, startPosition + text.length); 
							if (cutText == text) {
								this.io.currentCommand =  this.io.currentCommand.slice(0, startPosition) + this.io.currentCommand.slice(startPosition + text.length, this.io.currentCommand.length); 
							} else {
								window.webkit.messageHandlers.aShell.postMessage("Cannot find text = " + text + " in " + this.io.currentCommand); 
								// Do not cut if we don't agree on what to cut
								e.preventDefault();
								return; 
							}
						}
						// Move cursor to startLine, startOffset
						// We redraw the command ourselves because iOS removes extra spaces around the text.
						// var scrolledLines = window.promptScroll - term.scrollPort_.getTopRowIndex();
						// io.print('\x1b[' + (window.promptLine + scrolledLines + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor to position at start of line
						currentCommandCursorPosition = startPosition
						var ycursor = startRow - this.scrollPort_.getTopRowIndex();
						this.io.print('\x1b[' + (ycursor + 1) + ';' + (xcursor + 1) + 'H'); // move cursor to new position 
						this.io.print('\x1b[0J'); // delete display after cursor
						var endOfCommand = this.io.currentCommand.slice(startPosition, this.io.currentCommand.length); 
						this.io.print(endOfCommand); 
						this.io.print('\x1b[' + (ycursor + 1) + ';' + (xcursor + 1) + 'H'); // move cursor back to new position 
						return;
					}
					// Do not cut if we are outside the command line:
					e.preventDefault();
				};
				// 
				term.onTerminalReady = function() {
					const io = this.io.push();
					io.onVTKeystroke = (string) => {
						// window.webkit.messageHandlers.aShell.postMessage('received key input:' + string);
						if (window.controlOn) {
							// produce string = control + character 
							var charcode = string.toUpperCase().charCodeAt(0);
							string = String.fromCharCode(charcode - 64);
							window.controlOn = false;
							window.webkit.messageHandlers.aShell.postMessage('controlOff');
						}
						if (window.commandRunning.startsWith("vim")) {
							// specific treatment for editors: forward all keyboard input to the editor
							// TODO: do the same for other editors (when there are some)
							// window.webkit.messageHandlers.aShell.postMessage('sending: ' + string); // for debugging
							window.webkit.messageHandlers.aShell.postMessage('input:' + string);
						} else if ((window.commandRunning != '') && ((string.charCodeAt(0) == 3) || (string.charCodeAt(0) == 4))) {
							// Send control messages back to command:
							// first, flush existing input:
							if (io.currencCommand != '') {
								window.webkit.messageHandlers.aShell.postMessage('input:' + io.currentCommand);
								io.currentCommand = '';
							}
							window.webkit.messageHandlers.aShell.postMessage('input:' + string);
						} else { 
							if (io.currentCommand === '') { 
								// new line, reset things: (required for commands inside commands)
								updatePromptPosition(); 
							}
							var cursorPosition = term.screen_.cursorPosition.column - window.promptEnd;  // remove prompt length
							switch (string) {
								case '\r':
									if (autocompleteOn) {
										// Autocomplete menu being displayed + press return: select what's visible and remove
										pickCurrentValue();
										break;
									}
									// Before executing command, move to end of line if not already there:
									// Compute how many lines should we move downward:
									var beginCommand = io.currentCommand.slice(0, currentCommandCursorPosition); 
									var lineCursor = Math.floor((lib.wc.strWidth(beginCommand) + window.promptEnd)/ term.screenSize.width);
									var lineEndCommand = Math.floor((lib.wc.strWidth(io.currentCommand) + window.promptEnd)/ term.screenSize.width);
									for (var i = 0; i < lineEndCommand - lineCursor; i++) {
										io.println('');
									}
									io.println('');
									if (window.commandRunning != '') {
										// The command takes care of the prompt. Just send the input data:
										window.webkit.messageHandlers.aShell.postMessage('input:' + io.currentCommand + '\n');
										// remove temporarily stored command -- if any
										if (window.maxCommandInsideCommandIndex < window.commandInsideCommandArray.length) {
											window.commandInsideCommandArray.pop();
										}
										// only store non-empty commands:
										// store commands sent:
										if (io.currentCommand.length > 0) {
											if (io.currentCommand != window.commandInsideCommandArray[window.maxCommandInsideCommandIndex - 1]) {
												// only add command to history if it is different from the last one:
												window.maxCommandInsideCommandIndex = window.commandInsideCommandArray.push(io.currentCommand); 
											}
										} 
										while (window.maxCommandInsideCommandIndex >= 100) {
											// We have stored more than 100 commands
											window.commandInsideCommandArray.shift(); // remove first element
											window.maxCommandInsideCommandIndex = window.commandInsideCommandArray.length;
										} 
										window.commandInsideCommandIndex = window.maxCommandInsideCommandIndex; 
									} else {
										if (io.currentCommand.length > 0) {
											// Now is the time where we send the command to iOS: 
											window.webkit.messageHandlers.aShell.postMessage('shell:' + io.currentCommand);
											// and reinitialize:
											window.commandRunning = io.currentCommand;
											// remove temporarily stored command -- if any
											if (window.maxCommandIndex < window.commandArray.length) {
												window.commandArray.pop();
											}
											if (io.currentCommand != window.commandArray[window.maxCommandIndex - 1]) {
												// only add command to history if it is different from the last one:
												window.maxCommandIndex = window.commandArray.push(window.commandRunning); 
												while (window.maxCommandIndex >= 100) {
													// We have stored more than 100 commands
													window.commandArray.shift(); // remove first element
													window.maxCommandIndex = window.commandArray.length;
												} 
											} 
											window.commandIndex = window.maxCommandIndex; 
											// clear history inside command:
											window.commandInsideCommandArray = [];
											window.maxCommandInsideCommandIndex = 0;
										} else {
											printPrompt();
											updatePromptPosition(); 
										}
									}
									io.currentCommand = '';
									break;
								case String.fromCharCode(127): // delete key from iOS keyboard
									if (currentCommandCursorPosition > 0) { 
										var currentChar = io.currentCommand[currentCommandCursorPosition - 1];
										var currentCharWidth = lib.wc.strWidth(currentChar);
										// clear entire buffer, then reprint. This works even if we are several lines above end of line.
										for (var i = 0; i < currentCharWidth; i++) {
											io.print('\b'); // move cursor back n chars
										}
										io.print('\x1b[0J'); // delete display after cursor
										// print remainder of command line
										var endOfCommand = io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length);
										io.print(endOfCommand)
										// move cursor back to where it was (don't use term.screen_.cursorPosition):
										var wcwidth = lib.wc.strWidth(endOfCommand);
										for (var i = 0; i < wcwidth; i++) {
											io.print('\b'); 
										}
										// remove character from command at current position:
										io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition - 1) + 
											io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length); 
										currentCommandCursorPosition -= 1;
									}
									disableAutocompleteMenu();
									break;
								case String.fromCharCode(27):  // Escape. Make popup menu disappear
									disableAutocompleteMenu();
									break;
								case String.fromCharCode(27) + "[A":  // Up arrow
								case String.fromCharCode(27) + "[1;3A":  // Alt-Up arrow
									if (window.commandRunning != '') {
										if (window.commandInsideCommandIndex > 0) {
											if (window.commandInsideCommandIndex === window.maxCommandInsideCommandIndex) {
												// Store current command: 
												window.commandInsideCommandArray[window.commandInsideCommandIndex] = io.currentCommand;
											}
											io.print('\x1b[' + (window.promptLine + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor back to initial position
											io.print('\x1b[0J'); // delete display after cursor
											if (string == String.fromCharCode(27) + "[A") { 
												window.commandInsideCommandIndex -= 1;
											} else {
												window.commandInsideCommandIndex -= 5;
												if (window.commandInsideCommandIndex < 0) {
													window.commandInsideCommandIndex = 0;
												}
											}
											io.currentCommand = window.commandInsideCommandArray[window.commandInsideCommandIndex]; 
											io.print(io.currentCommand);
											currentCommandCursorPosition = io.currentCommand.length;
										}
									} else {
										// popup menu being displayed, change it:
										if (autocompleteOn) {
											if (autocompleteIndex > 0) {
												autocompleteIndex -= 1; 
												printAutocompleteString(autocompleteList[autocompleteIndex]);
											}													
											break;
										}
										if (window.commandIndex > 0) {
											if (window.commandIndex === window.maxCommandIndex) {
												// Store current command: 
												window.commandArray[window.commandIndex] = io.currentCommand;
											}
											var scrolledLines = window.promptScroll - term.scrollPort_.getTopRowIndex();
											io.print('\x1b[' + (window.promptLine + scrolledLines + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor to position at start of line
											io.print('\x1b[0J'); // delete display after cursor
											if (string == String.fromCharCode(27) + "[A") { 
												window.commandIndex -= 1;
											} else {
												window.commandIndex -= 5;
												if (window.commandIndex < 0) {
													window.commandIndex = 0;
												}
											}
											io.currentCommand = window.commandArray[window.commandIndex]; 
											io.print(io.currentCommand);
											currentCommandCursorPosition = io.currentCommand.length;
										} 
									}
									break;
								case String.fromCharCode(27) + "[B":  // Down arrow
								case String.fromCharCode(27) + "[1;3B":  // Alt-Down arrow
									if (window.commandRunning != '') {
										if (window.commandInsideCommandIndex < window.maxCommandInsideCommandIndex) {
											io.print('\x1b[' + (window.promptLine + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor to position at start of line
											io.print('\x1b[0J'); // delete display after cursor
											if (string == String.fromCharCode(27) + "[B") { 
												window.commandInsideCommandIndex += 1;
											} else {
												window.commandInsideCommandIndex += 5;
												if (window.commandInsideCommandIndex >= window.maxCommandInsideCommandIndex) {
													window.commandInsideCommandIndex = window.maxCommandInsideCommandIndex;
												}
											}
											io.currentCommand = window.commandInsideCommandArray[window.commandInsideCommandIndex]; 
											io.print(io.currentCommand);
											currentCommandCursorPosition = io.currentCommand.length;
										}
									} else {
										// popup menu being displayed, change it:
										if (autocompleteOn) {
											if (autocompleteIndex < autocompleteList.length - 1) {
												autocompleteIndex += 1; 
												printAutocompleteString(autocompleteList[autocompleteIndex]);
											}													
											break;
										}
										if (window.commandIndex < window.maxCommandIndex) {
											var scrolledLines = window.promptScroll - term.scrollPort_.getTopRowIndex();
											io.print('\x1b[' + (window.promptLine + scrolledLines + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor to position at start of line
											io.print('\x1b[0J'); // delete display after cursor
											if (string == String.fromCharCode(27) + "[B") { 
												window.commandIndex += 1;
											} else {
												window.commandIndex += 5;
												if (window.commandIndex >= window.maxCommandIndex) {
													window.commandIndex = window.maxCommandIndex;
												}
											}
											io.currentCommand = window.commandArray[window.commandIndex]; 
											io.print(io.currentCommand);
											currentCommandCursorPosition = io.currentCommand.length;
										}
									}
									break;
								case String.fromCharCode(27) + "[D":  // Left arrow
									disableAutocompleteMenu();
									if (currentCommandCursorPosition > 0) { // prompt.length
										var currentChar = io.currentCommand[currentCommandCursorPosition - 1];
										var currentCharWidth = lib.wc.strWidth(currentChar);
										for (var i = 0; i < currentCharWidth; i++) {
											io.print('\b'); // move cursor back n chars, across lines
										}
										currentCommandCursorPosition -= 1;
									}
									break;
								case String.fromCharCode(27) + "[C":  // Right arrow
									// recompute complete menu? For now, disable it.
									disableAutocompleteMenu();
									if (currentCommandCursorPosition < io.currentCommand.length) {
										var currentChar = io.currentCommand[currentCommandCursorPosition];
										var currentCharWidth = lib.wc.strWidth(currentChar);
										if (term.screen_.cursorPosition.column < term.screenSize.width - currentCharWidth) {
												io.print('\x1b[' + currentCharWidth + 'C'); // move cursor forward n chars
										} else {
											io.print('\x1b[' + (term.screen_.cursorPosition.row + 2) + ';' + 0 + 'H'); // move cursor to start of next line
										}
										currentCommandCursorPosition += 1;
									}
									break; 
								case String.fromCharCode(27) + "[1;3D":  // Alt-left arrow
									window.webkit.messageHandlers.aShell.postMessage('received alt-left arrow');
									disableAutocompleteMenu();
									if (currentCommandCursorPosition > 0) { // prompt.length
										while (currentCommandCursorPosition > 0) {
											currentCommandCursorPosition -= 1;
											var currentChar = io.currentCommand[currentCommandCursorPosition];
											var currentCharWidth = lib.wc.strWidth(currentChar);
											for (var i = 0; i < currentCharWidth; i++) {
												io.print('\b'); // move cursor back n chars, across lines
											}
											if  (!isLetter(currentChar)) {
												break;
											}
										}
									}
									break;
								case String.fromCharCode(27) + "[1;3C":  // Alt-right arrow
									window.webkit.messageHandlers.aShell.postMessage('received alt-right arrow');
									disableAutocompleteMenu();
									if (currentCommandCursorPosition < io.currentCommand.length) { // prompt.length
										while (currentCommandCursorPosition < io.currentCommand.length) {
											currentCommandCursorPosition += 1;
											var currentChar = io.currentCommand[currentCommandCursorPosition];
											var currentCharWidth = lib.wc.strWidth(currentChar);
											if (term.screen_.cursorPosition.column < term.screenSize.width - currentCharWidth) {
												io.print('\x1b[' + currentCharWidth + 'C'); // move cursor forward n chars
											} else {
												io.print('\x1b[' + (term.screen_.cursorPosition.row + 2) + ';' + 0 + 'H'); // move cursor to start of next line
											}
											if  (!isLetter(currentChar)) {
												break;
											}
										}
									}
									break;
								case String.fromCharCode(9):  // Tab, so autocomplete
									if (window.commandRunning == '') {
										if (autocompleteOn) {
											// hit tab when menu already visible = select current
											pickCurrentValue();
										} else {
											// Work on autocomplete list / current command
											updateAutocompleteMenu(io, currentCommandCursorPosition); 
										}
									} else {
										// no autocomplete inside running commands. Just print 4 spaces.
										// (spaces because tab confuse hterm)
										io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition) + "    " + 
											io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length);
										printString("    ");
										currentCommandCursorPosition += 4;
									}
									break;
								case String.fromCharCode(1):  // Ctrl-A: beginnging of line
									disableAutocompleteMenu();
									if (currentCommandCursorPosition > 0) { // prompt.length
										var scrolledLines = window.promptScroll - this.scrollPort_.getTopRowIndex();
										var topRowCommand = window.promptLine + scrolledLines;
										this.io.print('\x1b[' + (topRowCommand + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor to new position 
										currentCommandCursorPosition = 0; 
									}
									break;
								case String.fromCharCode(3):  // Ctrl-C: cancel current command
									disableAutocompleteMenu();
									// Before *not*-executing command, move to end of line if not already there:
									// Compute how many lines should we move downward:
									var beginCommand = io.currentCommand.slice(0, currentCommandCursorPosition); 
									var lineCursor = Math.floor((lib.wc.strWidth(beginCommand) + window.promptEnd)/ term.screenSize.width);
									var lineEndCommand = Math.floor((lib.wc.strWidth(io.currentCommand) + window.promptEnd)/ term.screenSize.width);
									for (var i = 0; i < lineEndCommand - lineCursor; i++) {
										io.println('');
									}
									io.println('');
									printPrompt();
									updatePromptPosition(); 
									io.currentCommand = '';
									currentCommandCursorPosition = 0;
									if (window.commandRunning != '') {
										window.commandInsideCommandIndex = window.maxCommandInsideCommandIndex; 
									} else { 									
										window.commandIndex = window.maxCommandIndex
									}
									break;
								case String.fromCharCode(4):  // Ctrl-D: deleter character after cursor TODO: test
									disableAutocompleteMenu();
									if (currentCommandCursorPosition < io.currentCommand.length) {
										var currentChar = io.currentCommand[currentCommandCursorPosition];
										var currentCharWidth = lib.wc.strWidth(currentChar);
										io.print('\x1b[0J'); // delete display after cursor
										// print remainder of command line
										var endOfCommand = io.currentCommand.slice(currentCommandCursorPosition + 1, io.currentCommand.length);
										io.print(endOfCommand)
										// move cursor back to where it was (don't use term.screen_.cursorPosition):
										var wcwidth = lib.wc.strWidth(endOfCommand);
										for (var i = 0; i < wcwidth; i++) {
											io.print('\b'); 
										}
										// remove character from command at current position:
										io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition) + 
											io.currentCommand.slice(currentCommandCursorPosition + 1, io.currentCommand.length); 
									}
									break;
									
								case String.fromCharCode(5):  // Ctrl-E: end of line
									disableAutocompleteMenu();
									if (currentCommandCursorPosition < io.currentCommand.length) {
										var scrolledLines = window.promptScroll - this.scrollPort_.getTopRowIndex();
										var topRowCommand = window.promptLine + scrolledLines;
										var fullLength = lib.wc.strWidth(io.currentCommand) + window.promptEnd; 
										var y = Math.floor((fullLength / this.screenSize.width)) ;
										var x = fullLength - this.screenSize.width * y;
										y += topRowCommand
										
										this.io.print('\x1b[' + (y + 1) + ';' + (x + 1) + 'H'); // move cursor to new position 
										currentCommandCursorPosition = io.currentCommand.length; 
									}
									break;
								case String.fromCharCode(11):  // Ctrl-K: kill until end of line
									disableAutocompleteMenu();
									if (currentCommandCursorPosition < io.currentCommand.length) { 
										io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition)
										window.term_.io.print('\x1b[0J'); // delete display after cursor
									}
									break;
								default:
									// TODO: deactivate anything that is < 32
									// For debugging:
									// var charcode = string.charCodeAt(0);
									// window.webkit.messageHandlers.aShell.postMessage('' + charcode + " = " + string);
									// insert character at cursor position
									printString(string);  // print before we update io.currentCommand
									io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition) + string + 
										io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length);
									currentCommandCursorPosition += string.length;
									if (autocompleteOn) {
										updateAutocompleteMenu(io, currentCommandCursorPosition); 
									}
									break;
							}
						}
					};
					term.moveCursorPosition = function(y, x) {
						// If currentCommand is empty, update prompt position (JS is asynchronous, position might have been computed before the end of the scroll)
						if (io.currentCommand === '') { 
							updatePromptPosition(); 
						}
						// TODO: different treatment for interactive commands (vim)
						var scrolledLines = window.promptScroll - this.scrollPort_.getTopRowIndex();
						var topRowCommand = window.promptLine + scrolledLines;
						// Don't move cursor outside of current line
						if (y < topRowCommand) { 
							return; 
						}
						// this.screen_.setCursorPosition(y, x);  // does not update blinking cursor position
						if (x < window.promptEnd) {
							x = window.promptEnd;
						} 
						var deltay = this.screen_.cursorPosition.row - y;
						var deltax = this.screen_.cursorPosition.column - x;
						var deltaCursor = deltax + deltay * this.screenSize.width; // by how many *characters* should we move?
						if (currentCommandCursorPosition - deltaCursor > lib.wc.strWidth(io.currentCommand)) {
						    // If we are after the end of the line, move to the end of the line.
							var overclick = currentCommandCursorPosition - deltaCursor - lib.wc.strWidth(io.currentCommand);
							deltaCursor += overclick;
							// At the end of the line, so move there.
							var fullLength = lib.wc.strWidth(io.currentCommand) + window.promptEnd; 
							var y = Math.floor((fullLength / this.screenSize.width)) ;
							var x = fullLength - this.screenSize.width * y;
							y += topRowCommand
						}
						// Now compute the new position inside the command line, taking into account multi-byte characters.
						// We assume characters have a width of at least 1, so we move of at least deltaCursor.
						var newCursorPosition = currentCommandCursorPosition - deltaCursor; 
						if (deltaCursor > 0) { 
							var string = io.currentCommand.slice(newCursorPosition, currentCommandCursorPosition);
							while (lib.wc.strWidth(string) > deltaCursor) {
								newCursorPosition += 1; 
								string = io.currentCommand.slice(newCursorPosition, currentCommandCursorPosition);
							}
						} else {
							var string = io.currentCommand.slice(currentCommandCursorPosition, newCursorPosition);
							while (lib.wc.strWidth(string) > -deltaCursor) {
								newCursorPosition -= 1; 
								string = io.currentCommand.slice(currentCommandCursorPosition, newCursorPosition);
							}
						}
						currentCommandCursorPosition = newCursorPosition;
						io.print('\x1b[' + (y + 1) + ';' + (x + 1) + 'H'); // move cursor to new position 
					};
					io.sendString = io.onVTKeystroke; // was io.print
					initContent(io);
					printPrompt(); // first prompt
					updatePromptPosition(); 
					this.setCursorVisible(true);
					this.setForegroundColor(window.foregroundColor);
					this.setBackgroundColor(window.backgroundColor);
					this.setCursorColor(window.cursorColor);
					this.keyboard.characterEncoding = 'raw';
					// this.keyboard.bindings.addBinding('F11', 'PASS');
					// this.keyboard.bindings.addBinding('Ctrl-R', 'PASS');
					
				};
				term.decorate(document.querySelector('#terminal'));
				term.installKeyboard();
                // Useful for console debugging.
				window.term_ = term;
				window.commandRunning = '';
				window.commandArray = new Array();
				window.commandInsideCommandArray = new Array();
				window.commandIndex = 0;
				window.maxCommandIndex = 0;
				window.commandInsideCommandIndex = 0;
				window.maxCommandInsideCommandIndex = 0;
				window.prompt = "$ "; // prompt for commands, configurable
				window.promptEnd = 2; // prompt for commands, configurable
				window.promptLine = 0; // term line on which the prompt started
				window.promptScroll = 0; // scroll line on which the scrollPort was when the prompt started
			}

window.onload = function() {
	lib.init(setupHterm);
	window.term_.focus(); 
};
		</script>

	</body>
</html>
